{
    "collab_server" : "",
    "contents" : "---\noutput: ioslides_presentation\n---\n\n# Databases to Documents with RMarkdown\n\nInstructor: Ian Carroll\n\n```{r include = FALSE}\nknitr::opts_chunk$set(echo = TRUE, eval = FALSE)\n```\n\n## Review\n\nThe workflow we want to create begins with data, moves through processing, analysis and visualization, and ends with content for a final report or perhaps the complete report itself. We use `git` and GitHub, which facilitate collaboration and maintain project integrity, to manage the creation of this workflow.\n\nBut how do we tie it all together to make the workflow ... work?\n\n## Objective\n\n1. Use RMarkdown and `knitr` to contain the whole workflow in one document.\n1. Connect the workflow to a database rather than a CSV files.\n1. Recognize how modularization helps make workflows successful.\n   \n## RMarkdown and `knitr`\n\nRMarkdown, like R itself, is both a language and an interpreter. The language component is a set of special characters and structural rules to incorporate in a plain text document that serve as formatting instructions. The interpreter reads the instructions along with any other text to generate a formatted document.\n\nThe `knitr` package will excute everything you've indicated as R script within an RMarkdown document, and optionally include results in the formatted document.\n\n## Seeing is believing\n\n```{r eval = TRUE}\nvals <- c(4, 5, 6)\ndata <- data.frame(counts = vals)\ndata\n```\n\nTake a look at `lesson-4.Rmd` -- there's no output written here.\n\n## RMarkdown Formatting\n\nThe document begins with a header section between `---` lines that assigns values to configuration variables:\n\n    ---\n    output: html_document\n    incremental: true\n    ---\n\n***\n\nAny number of `#` symbols denotes headers of the corresponding size\n\n    # The Biggest Heading\n    ## The Next Biggest Heading\n    ### Etc ...\n\nBlock quotes, like these two syntax examples, are produced with text indented 4 spaces.\n\n***\n\nA code chunk is fenced with ` ```{r} `, that's three backtick characters, above and ` ``` ` below the code.\n\n> \\`\\`\\`{r eval = TRUE, echo = FALSE}  \n> vals <- c(4, 5, 6)  \n> \\`\\`\\`\n\nCode chunk options, such as `eval = TRUE` and `echo = FALSE` above, are specified in a comma separated list.\n\n## Code chunks\n\nA value defined in one code chunk, i.e.\n\n```{r eval = TRUE}\nvals <- c(4, 5, 6)\n```\n\nis accessible in another:\n\n```{r eval = TRUE}\nvals + 1\n```\n\n## Exercise\n\nCreate a code chunk that reads the \"surveys.csv\" table into a variable named \"surveys\", but is essentially invisible.\n\n    ...\n\n```{r echo = FALSE}\nsurveys <- read.csv('data/surveys.csv')\n```\n\n## Create your formatted document\n\nChoose the \"Knit HTML\" option at the top of the editor.\n\n## Databases\n\nThe `dplyr` package includes `src_*` commands for connecting to three types of databases: SQLite, MySQL and PostgreSQL.\n\n### Features of a database\n\n- There is a standardized language, SQL, for scripting interactions with data.\n- MySQL and PostgreSQL are server based and multi-user.\n- It can hold more data than your computer can hold in memory.\n\n## Connecting to a database\n\n```{r eval = TRUE}\nlibrary(dplyr)\ndb <- src_sqlite(\"data/portal.sqlite\")\n```\n\n## Accessing tables\n\n```{r eval = TRUE}\nsurveys <- tbl(db, 'surveys')\nspecies <- tbl(db, 'species')\n```\n\n## Tidy databases\n\nRecall the principles of tidy data:\n\n- each variable forms a column\n- each observation forms a row\n- each type of observational unit forms a table\n\nThe last principle encapsulates a core approach to database design: try to never duplicate data about the same observation across rows in the \"wrong\" table.\n\n***\n\nCombine information in two tables based on matching the values of variables they share. We use this feature to add information (from the *species* table) pertaining to each species listed in the *counts_1990_winter* summary.\n\n```{r}\ncounts_1990_winter <- filter(surveys, year == 1990) %>%\n  select(-year) %>%\n  group_by(species_id) %>%\n  summarize(count = n())\n\ninner_join(counts_1990_winter, species)\n```\n\n## When **un-**tidy data is okay\n\nUntidy data is often needed for analysis, but it's not a good way to store data. Instead, join the tables only when needed.\n\n```{r}\nlibrary(ggplot2)\nsurveys_1990_winter <- filter(surveys, year == 1990) %>%\n  select(-year) %>%\n  inner_join(species) %>%\n  filter(taxa == 'Rodent') %>%\n  collect()\n\nggplot(data = surveys_1990_winter,\n       aes(x = genus)) +\n  geom_boxplot(aes(y = weight))\n```\n\n## Exercise\n\nCreate a bar plot for the abundance of species in the rodent taxa.\n\n```{r}\nrodents <- filter(surveys, year == 1990) %>%\n  group_by(species_id) %>%\n  summarize(count = n()) %>%\n  inner_join(species) %>%\n  filter(taxa == 'Rodent') %>%\n  collect()\n\nggplot(rodents,\n       aes(x = species_id, y = count)) +\n  geom_bar(stat = 'identity')\n```\n\n\n\n## Exercise\n\nThe third table, plots, gives details on the plot type. Create a code chunk that shows box plots for the weight of rodents in 1990 across the types of plot.\n\n   ...\n\n```{r}\nplots <- tbl(db, 'plots')\nrodents <- filter(surveys, year == 1990) %>%\n  inner_join(species) %>%\n  inner_join(plots) %>%\n  filter(taxa == 'Rodent') %>%\n  collect()\n\nggplot(rodents,\n       aes(x = plot_type, y = weight)) +\n  geom_boxplot()\n```\n",
    "created" : 1472494890498.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1114871417",
    "id" : "61AD607F",
    "lastKnownWriteTime" : 1472494895,
    "last_content_update" : 1472494895701,
    "path" : "~/projects/sesync-ci.github/basic-RMarkdown-lesson/index.Rmd",
    "project_path" : "index.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}